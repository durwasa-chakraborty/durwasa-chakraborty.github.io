<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Major Mode El | Anachronistic Monk</title>
<meta name="keywords" content="programming">
<meta name="description" content="Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.
Before you think I&rsquo;m crowning Lisp as God&rsquo;s own language after just one blog stint at a coding exercise, hold your horses. I&rsquo;m not here to bash Object-Oriented Programming or its design patterns. In fact, I believe it&rsquo;s crucial to know these patterns inside out. Only then can you play the game of &lsquo;Design Pattern or Anti-Pattern?">
<meta name="author" content="durwasa">
<link rel="canonical" href="https://durwasa-chakraborty.github.io/posts/major-mode-el/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e087fd1dc76e73a35ae6d7028ddc1ba41e0131e7f9b3a6e2d019a208e6d6c4b5.css" integrity="sha256-4If9Hcduc6Na5tcCjdwbpB4BMef5s6bi0BmiCObWxLU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://durwasa-chakraborty.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://durwasa-chakraborty.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://durwasa-chakraborty.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://durwasa-chakraborty.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://durwasa-chakraborty.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Major Mode El" />
<meta property="og:description" content="Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.
Before you think I&rsquo;m crowning Lisp as God&rsquo;s own language after just one blog stint at a coding exercise, hold your horses. I&rsquo;m not here to bash Object-Oriented Programming or its design patterns. In fact, I believe it&rsquo;s crucial to know these patterns inside out. Only then can you play the game of &lsquo;Design Pattern or Anti-Pattern?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://durwasa-chakraborty.github.io/posts/major-mode-el/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T18:08:54+05:30" />
<meta property="article:modified_time" content="2024-01-06T18:08:54+05:30" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Major Mode El"/>
<meta name="twitter:description" content="Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.
Before you think I&rsquo;m crowning Lisp as God&rsquo;s own language after just one blog stint at a coding exercise, hold your horses. I&rsquo;m not here to bash Object-Oriented Programming or its design patterns. In fact, I believe it&rsquo;s crucial to know these patterns inside out. Only then can you play the game of &lsquo;Design Pattern or Anti-Pattern?"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://durwasa-chakraborty.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Major Mode El",
      "item": "https://durwasa-chakraborty.github.io/posts/major-mode-el/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Major Mode El",
  "name": "Major Mode El",
  "description": "Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.\nBefore you think I\u0026rsquo;m crowning Lisp as God\u0026rsquo;s own language after just one blog stint at a coding exercise, hold your horses. I\u0026rsquo;m not here to bash Object-Oriented Programming or its design patterns. In fact, I believe it\u0026rsquo;s crucial to know these patterns inside out. Only then can you play the game of \u0026lsquo;Design Pattern or Anti-Pattern?",
  "keywords": [
    "programming"
  ],
  "articleBody": " Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.\nBefore you think I’m crowning Lisp as God’s own language after just one blog stint at a coding exercise, hold your horses. I’m not here to bash Object-Oriented Programming or its design patterns. In fact, I believe it’s crucial to know these patterns inside out. Only then can you play the game of ‘Design Pattern or Anti-Pattern?’ with any confidence. Remember, these musings are all from my little corner of the world and don’t reflect the hard work of other developers who’ve been sweating over StarPlat.\nNow, it’s not every day that I wake up with a burning desire to write a major mode for Emacs. Most programming languages already have their major modes written by far more ambitious souls. However, in my journey at IIT Madras I stumbled upon a DSL called StarPlat, which didn’t have its own major mode in Emacs. So, I thought, ‘Why not?’ and set out to create one, partly for the challenge, partly for my own learning.\nThe syntax highlighting looks something like this: Syntax Highlighting: In Emacs Lisp, we use font-lock-defaults, a buffer-local variable. It needs a list that describes the syntax of the language for which the major mode is set. Here’s how it looks for StarPlat: (defvar starplat-font-lock-keywords (let* ( ;; Define the list of keywords (keywords '(\"if\" \"else\" \"return\" \"function\" \"for\" \"while\" \"in\")) ;; Define the list of built-in-functions (built-in-funcs '(\"iterateInBFS\" \"iterateInReverse\")) (data-types '(\"int\" \"float\" \"string\" \"bool\" \"SetN\" \"SetE\")) ;; accumulate regexp strings for each keyword category (keywords-regexp (regexp-opt keywords 'words)) (data-types-regexp (regexp-opt data-types 'words)) (built-in-funcs-regexp (regexp-opt built-in-funcs 'words))) `( (,keywords-regexp . font-lock-keyword-face) (,data-types-regexp . font-lock-type-face) (,built-in-funcs-regexp . font-lock-builtin-face) ;; TODO: add further patterns that require syntax highlighting ))) Reference: various syntax highlighting options\nLet’s breakdown what is happening here -\nIn Emacs Lisp, a pair of values is often represented as a cons cell. Here, (,keywords-regexp . font-lock-keyword-face) is a cons cell where ,keywords-regexp is the car (the first element) and font-lock-keyword-face is the cdr (the second element).\nIn detail:\nfont-lock-keyword-face: This is one of the predefined faces in Emacs for syntax highlighting (font-locking in Emacs terminology). Emacs uses it by default to highlight keywords.\n,keywords-regexp: The comma character at the beginning signals that keywords-regexp is a symbol that needs to be evaluated. The rules of keywords-regexp have been neatly highlighted in the let* block.\n┌─────────────┐ │ │ │ Bag of Words│ │ │ │ │ └──────┬──────┘ │ ┌─────────────┼─────────────┐ │ │ │ Regex Match ┌─┴─┐ ┌─┴─┐ ┌─┴─┐ │ │ │ │ │ │ │Key- │Built-in │Data- │words │ types │types │ │ │ │ │ │ └─┬─┘ └─┬─┘ └─┬─┘ │ │ │ Transformation └─────────────┼─────────────┘ │ ┌──────┴──────┐ │ │ │ Bag of Words│ │ │ └─────────────┘ This particular list, can be a list of keywords, data-types, built-in-funcs Reference: extensive documentation on how to use font-lock-defaults and related functions.\nImagine you’re teaching a black box to play ‘color by numbers’ with words. You need to:\na. Define the pattern (the number). b. Assign a color to each pattern. c. Watch as the black box colors your words accordingly. This is essentially the famous ‘Interpreter Pattern’, but in Lisp, it feels like you’re just casually tossing words into a magic cauldron and watching them transform. It’s a smooth, almost effortless approach to syntax highlighting that showcases Lisp’s elegance and power.\n",
  "wordCount" : "568",
  "inLanguage": "en",
  "datePublished": "2024-01-06T18:08:54+05:30",
  "dateModified": "2024-01-06T18:08:54+05:30",
  "author":{
    "@type": "Person",
    "name": "durwasa"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://durwasa-chakraborty.github.io/posts/major-mode-el/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Anachronistic Monk",
    "logo": {
      "@type": "ImageObject",
      "url": "https://durwasa-chakraborty.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://durwasa-chakraborty.github.io/" accesskey="h" title="Anachronistic Monk (Alt + H)">Anachronistic Monk</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Major Mode El
    </h1>
    <div class="post-meta"><span title='2024-01-06 18:08:54 +0530 IST'>January 6, 2024</span>&nbsp;·&nbsp;durwasa

</div>
  </header> 
  <div class="post-content"><blockquote>
<p>Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.</p>
</blockquote>
<p>Before you think I&rsquo;m crowning Lisp as God&rsquo;s own language after just one blog stint at a coding exercise, hold your horses. I&rsquo;m not here to bash Object-Oriented Programming or its design patterns. In fact, I believe it&rsquo;s crucial to know these patterns inside out. Only then can you play the game of &lsquo;Design Pattern or Anti-Pattern?&rsquo; with any confidence. Remember, these musings are all from my little corner of the world and don&rsquo;t reflect the hard work of other developers who’ve been sweating over <a href="https://arxiv.org/pdf/2305.03317.pdf">StarPlat</a>.</p>
<p>Now, it&rsquo;s not every day that I wake up with a burning desire to write a major mode for Emacs. Most programming languages already have their major modes written by far more ambitious souls. However, in my journey at IIT Madras I stumbled upon a DSL called <a href="https://arxiv.org/pdf/2305.03317.pdf">StarPlat</a>, which didn&rsquo;t have its own major mode in Emacs. So, I thought, &lsquo;Why not?&rsquo; and set out to create one, partly for the challenge, partly for my own learning.</p>
<p>The syntax highlighting looks something like this:
<img loading="lazy" src="/images/syntax_highlighting.png" alt="syntax-highlight"  />
</p>
<ul>
<li>Syntax Highlighting:
In Emacs Lisp, we use font-lock-defaults, a buffer-local variable. It needs a list that describes the syntax of the language for which the major mode is set. Here&rsquo;s how it looks for StarPlat:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(defvar starplat-font-lock-keywords
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">let*</span> (
</span></span><span style="display:flex;"><span>         <span style="color:#75715e">;; Define the list of keywords</span>
</span></span><span style="display:flex;"><span>         (keywords <span style="color:#f92672">&#39;</span>(<span style="color:#e6db74">&#34;if&#34;</span> <span style="color:#e6db74">&#34;else&#34;</span> <span style="color:#e6db74">&#34;return&#34;</span> <span style="color:#e6db74">&#34;function&#34;</span> <span style="color:#e6db74">&#34;for&#34;</span> <span style="color:#e6db74">&#34;while&#34;</span> <span style="color:#e6db74">&#34;in&#34;</span>))
</span></span><span style="display:flex;"><span>         <span style="color:#75715e">;; Define the list of built-in-functions</span>
</span></span><span style="display:flex;"><span>         (built-in-funcs <span style="color:#f92672">&#39;</span>(<span style="color:#e6db74">&#34;iterateInBFS&#34;</span> <span style="color:#e6db74">&#34;iterateInReverse&#34;</span>))
</span></span><span style="display:flex;"><span>         (data-types <span style="color:#f92672">&#39;</span>(<span style="color:#e6db74">&#34;int&#34;</span> <span style="color:#e6db74">&#34;float&#34;</span> <span style="color:#e6db74">&#34;string&#34;</span> <span style="color:#e6db74">&#34;bool&#34;</span> <span style="color:#e6db74">&#34;SetN&#34;</span> <span style="color:#e6db74">&#34;SetE&#34;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>         <span style="color:#75715e">;; accumulate regexp strings for each keyword category</span>
</span></span><span style="display:flex;"><span>         (keywords-regexp (regexp-opt keywords <span style="color:#e6db74">&#39;words</span>))
</span></span><span style="display:flex;"><span>         (data-types-regexp (regexp-opt data-types <span style="color:#e6db74">&#39;words</span>))
</span></span><span style="display:flex;"><span>         (built-in-funcs-regexp (regexp-opt built-in-funcs <span style="color:#e6db74">&#39;words</span>)))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">`</span>(
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      (<span style="color:#f92672">,</span>keywords-regexp <span style="color:#f92672">.</span> font-lock-keyword-face)
</span></span><span style="display:flex;"><span>      (<span style="color:#f92672">,</span>data-types-regexp <span style="color:#f92672">.</span> font-lock-type-face)
</span></span><span style="display:flex;"><span>      (<span style="color:#f92672">,</span>built-in-funcs-regexp <span style="color:#f92672">.</span> font-lock-builtin-face)
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">;; TODO: add further patterns that require syntax highlighting</span>
</span></span><span style="display:flex;"><span>         )))
</span></span></code></pre></div><p>Reference: <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Faces-for-Font-Lock.html">various syntax highlighting options</a></p>
<p>Let&rsquo;s breakdown what is happening here -</p>
<p>In Emacs Lisp, a pair of values is often represented as a <code>cons</code> cell. Here, <code>(,keywords-regexp . font-lock-keyword-face)</code> is a <code>cons</code> cell where <code>,keywords-regexp</code> is the <code>car</code> (the first element) and <code>font-lock-keyword-face</code> is the <code>cdr</code> (the second element).</p>
<p>In detail:</p>
<ul>
<li>
<p><strong><code>font-lock-keyword-face</code></strong>: This is one of the predefined faces in Emacs for syntax highlighting (font-locking in Emacs terminology). Emacs uses it by default to highlight keywords.</p>
</li>
<li>
<p><strong><code>,keywords-regexp</code></strong>: The comma character at the beginning signals that <code>keywords-regexp</code> is a symbol that needs to be evaluated. The rules of <code>keywords-regexp</code> have been neatly highlighted in the <code>let*</code> block.</p>
</li>
</ul>
<pre tabindex="0"><code class="language-ascii" data-lang="ascii">         ┌─────────────┐
         │             │
         │ Bag of Words│
         │             │
         │             │
         └──────┬──────┘
                │
  ┌─────────────┼─────────────┐
  │             │             │  Regex Match
┌─┴─┐         ┌─┴─┐         ┌─┴─┐
│   │         │   │         │   │
│Key-         │Built-in     │Data-
│words        │  types      │types
│   │         │   │         │   │
└─┬─┘         └─┬─┘         └─┬─┘
  │             │             │  Transformation 
  └─────────────┼─────────────┘
                │
         ┌──────┴──────┐
         │             │
         │ Bag of Words│
         │             │
         └─────────────┘
</code></pre><p>This particular list, can be a list of keywords, data-types, built-in-funcs
Reference: <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Font-Lock-Basics.html#Font-Lock-Basics">extensive documentation</a> on how to use <code>font-lock-defaults</code> and related functions.</p>
<p>Imagine you&rsquo;re teaching a black box to play &lsquo;color by numbers&rsquo; with words. You need to:</p>
<pre><code>a. Define the pattern (the number).
b. Assign a color to each pattern.
c. Watch as the black box colors your words accordingly.
</code></pre>
<p>This is essentially the famous &lsquo;Interpreter Pattern&rsquo;, but in Lisp, it feels like you&rsquo;re just casually tossing words into a magic cauldron and watching them transform. It&rsquo;s a smooth, almost effortless approach to syntax highlighting that showcases Lisp’s elegance and power.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://durwasa-chakraborty.github.io/tags/programming/">programming</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://durwasa-chakraborty.github.io/">Anachronistic Monk</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>

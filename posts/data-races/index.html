<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Data Races | Anachronistic Monk</title>
<meta name="keywords" content="">
<meta name="description" content="“Data races are bad.” — Every systems programming course, ever.
But why are they bad? And what exactly are they?
Let’s be a little Aristotelian about this—question everything. So here we go:

So&hellip; What Is a Data Race?

A data race occurs when two or more concurrent threads access the same memory location , at least one of them performs a write, and there&rsquo;s no synchronization mechanism (like a lock or atomic operation) protecting that access.">
<meta name="author" content="durwasa">
<link rel="canonical" href="https://durwasa-chakraborty.github.io/posts/data-races/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://durwasa-chakraborty.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://durwasa-chakraborty.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://durwasa-chakraborty.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://durwasa-chakraborty.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://durwasa-chakraborty.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://durwasa-chakraborty.github.io/posts/data-races/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\[', right: '\\]', display: true},
                {left: '\\(', right: '\\)', display: false}
            ],
            throwOnError : false
        });
    });
</script>


<meta property="og:url" content="https://durwasa-chakraborty.github.io/posts/data-races/">
  <meta property="og:site_name" content="Anachronistic Monk">
  <meta property="og:title" content="Data Races">
  <meta property="og:description" content="“Data races are bad.” — Every systems programming course, ever.
But why are they bad? And what exactly are they?
Let’s be a little Aristotelian about this—question everything. So here we go:
So… What Is a Data Race? A data race occurs when two or more concurrent threads access the same memory location , at least one of them performs a write, and there’s no synchronization mechanism (like a lock or atomic operation) protecting that access.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-04-06T18:50:32+05:30">
    <meta property="article:modified_time" content="2025-04-06T18:50:32+05:30">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Data Races">
<meta name="twitter:description" content="“Data races are bad.” — Every systems programming course, ever.
But why are they bad? And what exactly are they?
Let’s be a little Aristotelian about this—question everything. So here we go:

So&hellip; What Is a Data Race?

A data race occurs when two or more concurrent threads access the same memory location , at least one of them performs a write, and there&rsquo;s no synchronization mechanism (like a lock or atomic operation) protecting that access.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://durwasa-chakraborty.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Data Races",
      "item": "https://durwasa-chakraborty.github.io/posts/data-races/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Data Races",
  "name": "Data Races",
  "description": "“Data races are bad.” — Every systems programming course, ever.\nBut why are they bad? And what exactly are they?\nLet’s be a little Aristotelian about this—question everything. So here we go:\nSo\u0026hellip; What Is a Data Race? A data race occurs when two or more concurrent threads access the same memory location , at least one of them performs a write, and there\u0026rsquo;s no synchronization mechanism (like a lock or atomic operation) protecting that access.\n",
  "keywords": [
    
  ],
  "articleBody": "“Data races are bad.” — Every systems programming course, ever.\nBut why are they bad? And what exactly are they?\nLet’s be a little Aristotelian about this—question everything. So here we go:\nSo… What Is a Data Race? A data race occurs when two or more concurrent threads access the same memory location , at least one of them performs a write, and there’s no synchronization mechanism (like a lock or atomic operation) protecting that access.\nWhew. That’s a lot of words. Let’s unpack that.\n“Two or more threads” → We’re dealing with a multithreaded (or concurrent) program. A single-threaded program is too well-behaved to ever encounter a data race.\n“Same memory location” → Both threads are peeking (or poking) at the same variable.\n“At least one write” → If both threads are just reading, all’s peaceful. But the moment one tries to write—or update—the memory, conflict brews.\n“No synchronization” → No locks, no atomics, no coordination. It’s the memory access version of “every thread for itself.”\nPut all of that together, and you’ve got yourself a classic case of undefined behavior, kicking down the door and yelling: “You summoned me? Initiating FireRocket().”\nDekker’s Algorithm Just two threads doing two things each.\nInitial Setup We have two shared variables:\nint x = 0; int y = 0; And two threads:\nThread A: x = 1; r1 = y; Thread B: y = 1; r2 = x; That’s it. No mutex. No atomic. Just pure, unfiltered concurrent drama.\nWhat Should Be the Output? Let’s think like a sequential human being.\nIf Thread A runs fully before Thread B:\nx = 1; r1 = y; // r1 = 0 ---------------- y = 1; r2 = x; // r2 = 1 =\u003e r1 = 0, r2 = 1 If Thread B runs fully before Thread A:\ny = 1; r2 = x; // r2 = 0 ---------------- x = 1; r1 = y; // r1 = 1 =\u003e r1 = 1, r2 = 0 If both writes happen before both reads:\nx = 1; y = 1; r1 = y; // r1 = 1 r2 = x; // r2 = 1 =\u003e r1 = 1, r2 = 1 So our intuitive, reasonable human outputs are:\n(r1, r2) = (0, 1) (r1, r2) = (1, 0) (r1, r2) = (1, 1) All of these are fine and expected.\nBut Wait—A Quick Math Detour Let’s get mathematical for a second. If you have two threads and each one performs two operations (a write and a read), the total number of interleavings of those operations is given by:\n$$ [ \\binom{2 + 2}{2} = \\frac{(2 + 2)!}{2! \\cdot 2!} = \\frac{4!}{2! \\cdot 2!} = \\frac{24}{4} = 6 ] $$\nSo there are 6 valid interleavings of the operations from Thread A and Thread B.\nThese correspond to permutations where the relative order of operations within each thread is preserved. That is:\nx = 1 before r1 = y (Thread A’s order preserved) y = 1 before r2 = x (Thread B’s order preserved) Let’s list a few examples:\nA1 A2 B1 B2 → (r1 = 0, r2 = 1) A1 B1 A2 B2 → (r1 = 1, r2 = 1) B1 B2 A1 A2 → (r1 = 1, r2 = 0) B1 A1 B2 A2 → and so on… These 6 interleavings give rise to our expected outputs:\n(0,1), (1,0), and (1,1).\nIn general :: For $n$ threads, where each thread performs $o_1, o_2, \\cdot o_n$ memory operations, $$ [ \\text{Total Interleavings} = \\frac{(o_1 + o_2 + \\ldots + o_n)!}{o_1! \\cdot o_2! \\cdots o_n!} ] $$\nSo What’s the Problem? That nasty little (r1, r2) = (0, 0) doesn’t appear in any of the above 6 valid interleavings!\nWhy? Because it would require reading both x and y before either write has occurred, which violates the intra-thread ordering unless reads were moved before writes.\nThis is why:\nReordering breaks the mathematical expectation based on interleavings and causes outputs that should be impossible under sequential consistency.\nSo while our math predicted 6 nice, clean outcomes, the CPU/compiler pulls a little abracadabra, breaks the sequential spell, and suddenly:\n(r1, r2) = (0, 0) But Here’s the Twist… Suppose your compiler or hardware chooses to reorder instructions, perhaps assuming it knows best. (For example, reordering a load $\\rightarrow$ a store, among other classic computer architecture behaviors—which I’ll delve into in a separate post.)\nImagine this:\nBoth threads reorder the read before write. Now, Thread A reads y (which is still 0), then writes x = 1. Simultaneously, Thread B reads x (also still 0), then writes y = 1. So we get:\nr1 = y; // 0 r2 = x; // 0 x = 1; y = 1; =\u003e r1 = 0, r2 = 0 ← the \"impossible\" outcome! But that shouldn’t be possible, right?\nIf either thread had seen the other’s write, one of the reads should be 1.\nYet due to reordering and no synchronization, both reads saw 0.\nThis output:\n(r1, r2) = (0, 0) should be impossible under sequential consistency.\nBut under real-world hardware + compiler optimizations, it can happen.\nWhat is sequential consistency now? Leslie Lamport defines sequential consistency as:\n“The result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order issued.”\nTranslation: It should feel like all memory operations from all threads were executed in some sequential order, even if they were running concurrently.\n$$ \\forall a, b \\in S,\\ a \\leq b\\ \\vee\\ b \\leq a $$\nFor any two processes $p$ and $q$ you can always determine which one comes before the other (or that they are the same).\nThis contrasts with partial orders, where some processes might be incomparable like concurrent processes in a distributed system with no causal link. This implies a total order of all operations. That is, everything can be lined up in a single straight line.\nIf you only had partial order (like Thread A and Thread B doing stuff independently), you’d never know which came first.\nWhich is great for eggs, terrible for memory consistency.\nDear Compiler: Please Stop Being So Smart I mean, seriously. I wrote my code like this:\nx = 1; y = 2; I want you to do exactly that. Line by line.\nNo backflips, no clever tricks, no playing 4D chess with my instructions.\nI want you to translate it into assembly like a faithful scribe from an ecclesiastical journal—quietly, obediently, reverently.\nJust copy it down, convert into assembly, binary, the works!\nI’ve got the world’s biggest SSD, a GPU that can simulate Interstellar in 16K, and enough RAM to mine all the bitcoins—twice.\nOptimization is not my concern. I want correctness.\nSo what’s the problem?\nWell, here’s the catch: correctness isn’t the only thing you care about—even if you think it is.\nBecause guess what? Turning off every optimization doesn’t magically fix data races or memory consistency issues.\nThat bug you blamed on “compiler wizardry”?\nYeah, that’s on you, buddy.\nModern processors are sneaky little devils. They reorder instructions under the hood.\nThey prefetch, speculate, parallelize—all while laughing in binary.\nEven if the compiler leaves your code untouched, the hardware might still go, “eh, close enough.”\nSo unless you explicitly tell both the compiler and the CPU:\n“Hey, don’t mess this up—I mean it,”\nyou’re still rolling the dice.\nAnd if you think -O0 is your silver bullet?\nWell… welcome to the illusion of safety.\nLet’s Make That Concrete Here’s a simple-looking C++ example:\nint flag = 0; int data = 0; void writer() { data = 42; flag = 1; } void reader() { if (flag == 1) { printf(\"%d\\n\", data); } } Two threads. writer() sets data, then signals with flag. reader() checks flag and reads data.\nLooks innocent, right? But this code has a data race.\nNo locks, no atomics, no memory fences.\nEven with -O0, the compiler is allowed to reorder instructions because C++ says: “you gave me undefined behavior, so all bets are off.”\nSo What Happens? Maybe flag = 1 gets reordered before data = 42.\nMaybe reader() sees flag == 1, but reads stale or garbage from data.\nIt might run flawlessly on your machine, but crashes on the production server at 3AM—triggering a page and dragging you out of bed at an ungodly hour.\nFix It the Right Way #include std::atomic\u003cint\u003e flag{0}; int data = 0; void writer() { data = 42; flag.store(1, std::memory_order_release); } void reader() { if (flag.load(std::memory_order_acquire) == 1) { printf(\"%d\\n\", data); } } This version uses proper synchronization:\nmemory_order_release in writer() ensures data is visible before flag is updated. memory_order_acquire in reader() ensures data is read after confirming flag. Bottom Line? Correctness isn’t passive.\nYou don’t get it by turning knobs like -O0. You earn it by using the right tools—locks, atomics, memory barriers.\nBecause neither your compiler nor your CPU is in the business of babysitting your assumptions.\nWelcome to the real world!\nYou wanted a cup of water.\nThe compiler optimization will give you a caramel swirl, three skim, one sugar — and maybe some regret.\nSource\nIn the next part we will cover - Memory model of Programming Languages.\n",
  "wordCount" : "1551",
  "inLanguage": "en",
  "datePublished": "2025-04-06T18:50:32+05:30",
  "dateModified": "2025-04-06T18:50:32+05:30",
  "author":{
    "@type": "Person",
    "name": "durwasa"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://durwasa-chakraborty.github.io/posts/data-races/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Anachronistic Monk",
    "logo": {
      "@type": "ImageObject",
      "url": "https://durwasa-chakraborty.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://durwasa-chakraborty.github.io/" accesskey="h" title="Anachronistic Monk (Alt + H)">Anachronistic Monk</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Data Races
    </h1>
    <div class="post-meta"><span title='2025-04-06 18:50:32 +0530 IST'>April 6, 2025</span>&nbsp;·&nbsp;durwasa

</div>
  </header> 
  <div class="post-content"><p><em>“Data races are bad.”</em> — Every systems programming course, ever.<br>
But <strong>why</strong> are they bad? And <strong>what</strong> exactly are they?</p>
<p>Let’s be a little Aristotelian about this—<strong>question everything</strong>. So here we go:</p>
<hr>
<h3 id="so-what-is-a-data-race">So&hellip; What <em>Is</em> a Data Race?<a hidden class="anchor" aria-hidden="true" href="#so-what-is-a-data-race">#</a></h3>
<blockquote>
<p>A <strong>data race</strong> occurs when two or more concurrent threads access the <strong>same memory location</strong> , at least one of them performs a <strong>write</strong>, and there&rsquo;s <strong>no synchronization mechanism</strong> (like a lock or atomic operation) protecting that access.</p>
</blockquote>
<p>Whew. That’s a lot of words. Let’s unpack that.</p>
<ul>
<li>
<p>“Two or more threads” → We&rsquo;re dealing with a multithreaded (or concurrent) program. A single-threaded program is too well-behaved to ever encounter a data race.</p>
</li>
<li>
<p>“Same memory location” → Both threads are peeking (or poking) at the same variable.</p>
</li>
<li>
<p>“At least one write” → If both threads are just reading, all’s peaceful. But the moment one tries to write—or update—the memory, conflict brews.</p>
</li>
<li>
<p>“No synchronization” → No locks, no atomics, no coordination. It’s the memory access version of “every thread for itself.”</p>
</li>
</ul>
<p>Put all of that together, and you’ve got yourself a classic case of undefined behavior, kicking down the door and yelling:
“You summoned me? Initiating FireRocket().”</p>
<hr>
<h3 id="dekkers-algorithm">Dekker’s Algorithm<a hidden class="anchor" aria-hidden="true" href="#dekkers-algorithm">#</a></h3>
<p>Just two threads doing two things each.</p>
<h3 id="initial-setup">Initial Setup<a hidden class="anchor" aria-hidden="true" href="#initial-setup">#</a></h3>
<p>We have two shared variables:</p>
<pre tabindex="0"><code>int x = 0;
int y = 0;
</code></pre><p>And two threads:</p>
<h4 id="thread-a">Thread A:<a hidden class="anchor" aria-hidden="true" href="#thread-a">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>r1 <span style="color:#f92672">=</span> y;
</span></span></code></pre></div><h4 id="thread-b">Thread B:<a hidden class="anchor" aria-hidden="true" href="#thread-b">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>y <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>r2 <span style="color:#f92672">=</span> x;
</span></span></code></pre></div><p>That&rsquo;s it. No mutex. No atomic. Just pure, unfiltered <strong>concurrent drama</strong>.</p>
<h3 id="what-should-be-the-output">What Should Be the Output?<a hidden class="anchor" aria-hidden="true" href="#what-should-be-the-output">#</a></h3>
<p>Let’s think like a sequential human being.</p>
<p>If Thread A runs fully before Thread B:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>x = 1;
</span></span><span style="display:flex;"><span>r1 = y;   // r1 = 0
</span></span><span style="display:flex;"><span>----------------
</span></span><span style="display:flex;"><span>y = 1;
</span></span><span style="display:flex;"><span>r2 = x;   // r2 = 1
</span></span><span style="display:flex;"><span>=&gt; r1 = 0, r2 = 1
</span></span></code></pre></div><p>If Thread B runs fully before Thread A:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>y = 1;
</span></span><span style="display:flex;"><span>r2 = x;   // r2 = 0
</span></span><span style="display:flex;"><span>----------------
</span></span><span style="display:flex;"><span>x = 1;
</span></span><span style="display:flex;"><span>r1 = y;   // r1 = 1
</span></span><span style="display:flex;"><span>=&gt; r1 = 1, r2 = 0
</span></span></code></pre></div><p>If both writes happen before both reads:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>x = 1;
</span></span><span style="display:flex;"><span>y = 1;
</span></span><span style="display:flex;"><span>r1 = y;   // r1 = 1
</span></span><span style="display:flex;"><span>r2 = x;   // r2 = 1
</span></span><span style="display:flex;"><span>=&gt; r1 = 1, r2 = 1
</span></span></code></pre></div><p>So our <strong>intuitive, reasonable human outputs</strong> are:</p>
<ul>
<li><code>(r1, r2) = (0, 1)</code></li>
<li><code>(r1, r2) = (1, 0)</code></li>
<li><code>(r1, r2) = (1, 1)</code></li>
</ul>
<p>All of these are fine and expected.</p>
<h3 id="but-waita-quick-math-detour">But Wait—A Quick Math Detour<a hidden class="anchor" aria-hidden="true" href="#but-waita-quick-math-detour">#</a></h3>
<p>Let’s get mathematical for a second. If you have two threads and each one performs two operations (a write and a read), the total number of <strong>interleavings</strong> of those operations is given by:</p>
<p>$$
[
\binom{2 + 2}{2} = \frac{(2 + 2)!}{2! \cdot 2!} = \frac{4!}{2! \cdot 2!} = \frac{24}{4} = 6
]
$$</p>
<p>So there are <strong>6 valid interleavings</strong> of the operations from Thread A and Thread B.</p>
<p>These correspond to permutations where the <strong>relative order of operations within each thread is preserved</strong>. That is:</p>
<ul>
<li><code>x = 1</code> before <code>r1 = y</code> (Thread A’s order preserved)</li>
<li><code>y = 1</code> before <code>r2 = x</code> (Thread B’s order preserved)</li>
</ul>
<p>Let’s list a few examples:</p>
<ol>
<li>A1 A2 B1 B2 → <code>(r1 = 0, r2 = 1)</code></li>
<li>A1 B1 A2 B2 → <code>(r1 = 1, r2 = 1)</code></li>
<li>B1 B2 A1 A2 → <code>(r1 = 1, r2 = 0)</code></li>
<li>B1 A1 B2 A2 → and so on…</li>
</ol>
<p>These 6 interleavings give rise to our <strong>expected outputs</strong>:<br>
<code>(0,1)</code>, <code>(1,0)</code>, and <code>(1,1)</code>.</p>
<p>In general ::
For $n$ threads, where each thread performs $o_1, o_2, \cdot o_n$ memory operations,
$$
[
\text{Total Interleavings} = \frac{(o_1 + o_2 + \ldots + o_n)!}{o_1! \cdot o_2! \cdots o_n!}
]
$$</p>
<hr>
<h3 id="so-whats-the-problem">So What’s the Problem?<a hidden class="anchor" aria-hidden="true" href="#so-whats-the-problem">#</a></h3>
<p>That nasty little <code>(r1, r2) = (0, 0)</code> doesn’t appear in any of the above 6 valid interleavings!</p>
<p>Why? Because it would require <strong>reading both <code>x</code> and <code>y</code> before either write has occurred</strong>, which <strong>violates the intra-thread ordering</strong> unless reads were moved <em>before</em> writes.</p>
<p>This is why:</p>
<blockquote>
<p><strong>Reordering breaks the mathematical expectation</strong> based on interleavings and causes outputs that should be <strong>impossible under sequential consistency</strong>.</p>
</blockquote>
<p>So while our math predicted 6 nice, clean outcomes, the CPU/compiler pulls a little <em>abracadabra</em>, breaks the sequential spell, and suddenly:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>(r1, r2) = (0, 0)
</span></span></code></pre></div><h3 id="but-heres-the-twist">But Here’s the Twist&hellip;<a hidden class="anchor" aria-hidden="true" href="#but-heres-the-twist">#</a></h3>
<p>Suppose your compiler or hardware chooses to reorder instructions, perhaps assuming it knows best. (For example, reordering a load $\rightarrow$  a store, among other classic computer architecture behaviors—which I’ll delve into in a separate post.)</p>
<p>Imagine this:</p>
<ol>
<li>Both threads reorder the <strong>read before write</strong>.</li>
<li>Now, Thread A reads <code>y</code> (which is still 0), then writes <code>x = 1</code>.</li>
<li>Simultaneously, Thread B reads <code>x</code> (also still 0), then writes <code>y = 1</code>.</li>
</ol>
<p>So we get:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>r1 = y;   // 0
</span></span><span style="display:flex;"><span>r2 = x;   // 0
</span></span><span style="display:flex;"><span>x = 1;
</span></span><span style="display:flex;"><span>y = 1;
</span></span><span style="display:flex;"><span>=&gt; r1 = 0, r2 = 0   ← the &#34;impossible&#34; outcome!
</span></span></code></pre></div><p>But that shouldn’t be possible, right?</p>
<p>If either thread had seen the other&rsquo;s write, one of the reads should be 1.<br>
Yet due to <strong>reordering</strong> and <strong>no synchronization</strong>, both reads saw 0.</p>
<hr>
<p>This output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>(r1, r2) = (0, 0)
</span></span></code></pre></div><p><strong>should</strong> be impossible under <strong>sequential consistency</strong>.<br>
But under <strong>real-world hardware + compiler optimizations</strong>, it <em>can</em> happen.</p>
<h3 id="what-is-sequential-consistency-now">What is sequential consistency now?<a hidden class="anchor" aria-hidden="true" href="#what-is-sequential-consistency-now">#</a></h3>
<p>Leslie Lamport defines <strong>sequential consistency</strong> as:</p>
<blockquote>
<p><em>&ldquo;The result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order issued.&rdquo;</em></p>
</blockquote>
<p><strong>Translation</strong>: It should feel like <em>all memory operations from all threads were executed in some sequential order</em>, even if they were running concurrently.</p>
<p>$$
\forall a, b \in S,\ a \leq b\ \vee\ b \leq a
$$</p>
<p>For any two processes
$p$ and $q$ you can always determine which one comes before the other (or that they are the same).</p>
<p>This contrasts with partial orders, where some processes might be incomparable like concurrent processes in a distributed system with no causal link.
This implies a <strong>total order</strong> of all operations. That is, everything can be lined up in a single straight line.</p>
<p>If you only had <strong>partial order</strong> (like Thread A and Thread B doing stuff independently), you&rsquo;d never know which came first.<br>
Which is great for eggs, terrible for memory consistency.</p>
<h3 id="dear-compiler-please-stop-being-so-smart">Dear Compiler: Please Stop Being So Smart<a hidden class="anchor" aria-hidden="true" href="#dear-compiler-please-stop-being-so-smart">#</a></h3>
<p>I mean, seriously. I wrote my code like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>y <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span></code></pre></div><p>I want you to do <strong>exactly that</strong>. Line by line.<br>
No backflips, no clever tricks, no playing 4D chess with my instructions.</p>
<p>I want you to translate it into assembly like a faithful scribe from an ecclesiastical journal—quietly, obediently, reverently.<br>
Just copy it down, convert into assembly, binary, the works!</p>
<p>I’ve got the world’s biggest SSD, a GPU that can simulate <em>Interstellar</em> in 16K, and enough RAM to mine all the bitcoins—twice.<br>
<strong>Optimization is not my concern. I want correctness.</strong></p>
<p>So what’s the problem?</p>
<p>Well, here’s the catch: <strong>correctness isn’t the only thing you care about</strong>—even if you think it is.<br>
Because guess what? Turning off every optimization doesn’t magically fix <strong>data races</strong> or <strong>memory consistency issues</strong>.<br>
That bug you blamed on “compiler wizardry”?<br>
<strong>Yeah, that’s on you, buddy.</strong></p>
<hr>
<p>Modern processors are sneaky little devils. They reorder instructions under the hood.<br>
They prefetch, speculate, parallelize—all while laughing in binary.<br>
Even if the compiler leaves your code untouched, the hardware might still go, “eh, close enough.”</p>
<p>So unless you explicitly tell both the compiler <strong>and</strong> the CPU:</p>
<blockquote>
<p>“Hey, don’t mess this up—I mean it,”</p>
</blockquote>
<p>you&rsquo;re still rolling the dice.</p>
<p>And if you think <code>-O0</code> is your silver bullet?</p>
<p>Well&hellip; <strong>welcome to the illusion of safety.</strong></p>
<hr>
<h3 id="lets-make-that-concrete">Let’s Make That Concrete<a hidden class="anchor" aria-hidden="true" href="#lets-make-that-concrete">#</a></h3>
<p>Here&rsquo;s a simple-looking C++ example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> data <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">writer</span>() {
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>    flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reader</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (flag <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, data);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Two threads. <code>writer()</code> sets data, then signals with <code>flag</code>. <code>reader()</code> checks <code>flag</code> and reads <code>data</code>.</p>
<p>Looks innocent, right? But this code has a <strong>data race</strong>.<br>
No locks, no atomics, no memory fences.</p>
<p>Even with <code>-O0</code>, the compiler is <strong>allowed to reorder</strong> instructions because C++ says: <em>“you gave me undefined behavior, so all bets are off.”</em></p>
<hr>
<h3 id="so-what-happens">So What Happens?<a hidden class="anchor" aria-hidden="true" href="#so-what-happens">#</a></h3>
<p>Maybe <code>flag = 1</code> gets reordered before <code>data = 42</code>.</p>
<p>Maybe <code>reader()</code> sees <code>flag == 1</code>, but reads <strong>stale or garbage</strong> from <code>data</code>.</p>
<p>It might run flawlessly on your machine, but crashes on the production server at 3AM—triggering a page and dragging you out of bed at an ungodly hour.</p>
<hr>
<h3 id="fix-it-the-right-way">Fix It the Right Way<a hidden class="anchor" aria-hidden="true" href="#fix-it-the-right-way">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;atomic&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> flag{<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> data <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">writer</span>() {
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>    flag.store(<span style="color:#ae81ff">1</span>, std<span style="color:#f92672">::</span>memory_order_release);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reader</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (flag.load(std<span style="color:#f92672">::</span>memory_order_acquire) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, data);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This version uses proper synchronization:</p>
<ul>
<li><code>memory_order_release</code> in <code>writer()</code> ensures <code>data</code> is visible before <code>flag</code> is updated.</li>
<li><code>memory_order_acquire</code> in <code>reader()</code> ensures <code>data</code> is read <strong>after</strong> confirming <code>flag</code>.</li>
</ul>
<hr>
<h3 id="bottom-line">Bottom Line?<a hidden class="anchor" aria-hidden="true" href="#bottom-line">#</a></h3>
<p><strong>Correctness isn’t passive.</strong><br>
You don’t get it by turning knobs like <code>-O0</code>. You earn it by using the right tools—locks, atomics, memory barriers.</p>
<p>Because neither your compiler nor your CPU is in the business of babysitting your assumptions.</p>
<p>Welcome to the real world!</p>
<p>You wanted a <strong>cup of water</strong>.<br>
The compiler optimization will  give you a <em>caramel swirl, three skim, one sugar</em> — and maybe some regret.<br>
<a href="https://www.instagram.com/p/CZ0RjLzFOMX/">Source</a></p>
<p>In the next part we will cover - Memory model of Programming Languages.</p>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://durwasa-chakraborty.github.io/">Anachronistic Monk</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
